#!/usr/bin/env bash
# Worker wrapper for Claude Code orchestration
# Watches for task.json, executes prompts, writes results

set -euo pipefail

WORKER_ID="${1:-}"
WORK_DIR="${2:-.}"

if [ -z "$WORKER_ID" ]; then
  echo "Usage: $0 <worker_id> [work_dir]" >&2
  exit 1
fi

QUEUE_DIR="$HOME/.claude-code/orchestrator/workers/$WORKER_ID"
TASK_FILE="$QUEUE_DIR/task.json"
STATUS_FILE="$QUEUE_DIR/status.json"
RESULT_FILE="$QUEUE_DIR/result.json"
LOCK_FILE="$QUEUE_DIR/.lock"

mkdir -p "$QUEUE_DIR"
echo "{\"status\":\"idle\",\"timestamp\":$(date +%s)}" > "$STATUS_FILE"

log() { echo "[Worker $WORKER_ID] $*" >&2; }

acquire_lock() {
  local retries=5
  while [ $retries -gt 0 ]; do
    if mkdir "$LOCK_FILE" 2>/dev/null; then
      echo "$$" > "$LOCK_FILE/pid"
      return 0
    fi

    if [ -f "$LOCK_FILE/pid" ]; then
      local old_pid=$(cat "$LOCK_FILE/pid" 2>/dev/null || echo "0")
      if ! kill -0 "$old_pid" 2>/dev/null; then
        log "Removing stale lock from PID $old_pid"
        rm -rf "$LOCK_FILE"
        continue
      fi
    fi

    sleep 1
    retries=$((retries - 1))
  done
  return 1
}

release_lock() { rm -rf "$LOCK_FILE"; }

cleanup() {
  release_lock 2>/dev/null || true
  log "Shutting down"
}

trap cleanup EXIT INT TERM

process_task() {
  [ -f "$TASK_FILE" ] || return 0

  acquire_lock || { log "Failed to acquire lock"; return 1; }

  [ -f "$TASK_FILE" ] || { release_lock; return 0; }

  local task_id=$(jq -r '.id // empty' "$TASK_FILE")
  local prompt=$(jq -r '.prompt // empty' "$TASK_FILE")

  [ -z "$prompt" ] && { rm -f "$TASK_FILE"; release_lock; return 0; }

  log "Processing task $task_id"
  echo "{\"status\":\"working\",\"taskId\":$task_id,\"timestamp\":$(date +%s)}" > "$STATUS_FILE"

  cd "$WORK_DIR"

  local output=$(mktemp)
  local errors=$(mktemp)

  if echo "$prompt" | claude-code 2>"$errors" 1>"$output"; then
    jq -n \
      --arg tid "$task_id" \
      --arg out "$(cat "$output")" \
      '{taskId: $tid, output: $out, success: true, error: null, timestamp: now}' \
      > "$RESULT_FILE"
    echo "{\"status\":\"done\",\"taskId\":$task_id,\"timestamp\":$(date +%s)}" > "$STATUS_FILE"
    log "Task $task_id completed"
  else
    jq -n \
      --arg tid "$task_id" \
      --arg out "$(cat "$output")" \
      --arg err "$(cat "$errors")" \
      '{taskId: $tid, output: $out, success: false, error: $err, timestamp: now}' \
      > "$RESULT_FILE"
    echo "{\"status\":\"error\",\"taskId\":$task_id,\"timestamp\":$(date +%s)}" > "$STATUS_FILE"
    log "Task $task_id failed"
  fi

  rm -f "$output" "$errors" "$TASK_FILE"
  release_lock
}

log "Starting in $WORK_DIR"

if command -v inotifywait >/dev/null 2>&1; then
  log "Using inotify"
  while true; do
    [ -f "$TASK_FILE" ] && process_task
    inotifywait -q -e create,modify "$QUEUE_DIR" 2>/dev/null || true
    sleep 0.1
  done
elif command -v fswatch >/dev/null 2>&1; then
  log "Using fswatch"
  [ -f "$TASK_FILE" ] && process_task
  fswatch -0 "$QUEUE_DIR" | while read -d "" event; do
    [[ "$event" == *"task.json"* ]] && { sleep 0.1; process_task; }
  done
else
  log "Using polling (install inotify-tools or fswatch for better performance)"
  while true; do
    [ -f "$TASK_FILE" ] && process_task
    sleep 1
  done
fi
