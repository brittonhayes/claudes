#!/usr/bin/env python3
"""
Orchestrator for Claude Code - coordinates multiple worker sessions.
Usage: orchestrator <num_workers>
"""

import sys
import time
from pathlib import Path

# Add conductor to path
sys.path.insert(0, str(Path(__file__).parent.parent / 'conductor'))

from queue import (
    init_queue, create_worker, write_task, read_status,
    read_result, clear_result, write_status, wait_for_status, list_workers
)


class Orchestrator:
    """Coordinates work across multiple Claude Code workers."""

    def __init__(self, num_workers: int):
        self.num_workers = num_workers
        self.workers = []

        init_queue()

        for i in range(num_workers):
            create_worker(i)
            self.workers.append(i)

        print(f"Orchestrator initialized with {num_workers} workers")

    def find_idle_worker(self):
        """Find an idle worker."""
        for worker_id in self.workers:
            status = read_status(worker_id)
            if status['status'] in ('idle', 'done'):
                return worker_id
        return None

    def wait_for_available_worker(self, timeout=300):
        """Wait for any worker to become available."""
        start = time.time()
        while time.time() - start < timeout:
            worker_id = self.find_idle_worker()
            if worker_id is not None:
                return worker_id
            time.sleep(1)
        raise TimeoutError("Timeout waiting for available worker")

    def assign_task(self, worker_id: int, prompt: str, context=None):
        """Assign task to worker."""
        print(f"\n[Orchestrator] Assigning to worker {worker_id}")
        print(f"[Orchestrator] Task: {prompt[:80]}...")

        clear_result(worker_id)
        task_id = write_task(worker_id, prompt, context or {})
        return task_id

    def wait_for_completion(self, worker_id: int, timeout=300):
        """Wait for worker to complete task."""
        print(f"[Orchestrator] Waiting for worker {worker_id}...")

        status = wait_for_status(worker_id, ['done', 'error'], timeout)

        if status['status'] == 'error':
            print(f"[Orchestrator] Worker {worker_id} encountered error")
        else:
            print(f"[Orchestrator] Worker {worker_id} completed")

        return status

    def execute_tasks(self, tasks):
        """Execute tasks in parallel across workers."""
        results = []
        task_queue = list(tasks)
        active_workers = {}

        print(f"\n[Orchestrator] Executing {len(tasks)} tasks across {self.num_workers} workers")

        while task_queue or active_workers:
            # Assign tasks to idle workers
            while task_queue:
                worker_id = self.find_idle_worker()
                if worker_id is None:
                    break

                task = task_queue.pop(0)
                task_id = self.assign_task(worker_id, task['prompt'], task.get('context'))
                active_workers[worker_id] = {'taskId': task_id, 'task': task}

            # Check for completed workers
            if active_workers:
                for worker_id in list(active_workers.keys()):
                    status = read_status(worker_id)

                    if status['status'] in ('done', 'error'):
                        result = read_result(worker_id)
                        worker_info = active_workers[worker_id]

                        results.append({
                            'workerId': worker_id,
                            'taskId': worker_info['taskId'],
                            'task': worker_info['task'],
                            'result': result,
                            'status': status['status']
                        })

                        write_status(worker_id, 'idle')
                        del active_workers[worker_id]

                        print(f"[Orchestrator] Worker {worker_id} finished ({len(results)}/{len(tasks)})")

                time.sleep(0.5)

        return results

    def execute_sequential(self, tasks):
        """Execute tasks sequentially."""
        results = []

        print(f"\n[Orchestrator] Executing {len(tasks)} tasks sequentially")

        for i, task in enumerate(tasks):
            worker_id = self.wait_for_available_worker()

            print(f"\n[Orchestrator] Task {i + 1}/{len(tasks)}")

            task_id = self.assign_task(worker_id, task['prompt'], task.get('context'))
            self.wait_for_completion(worker_id)

            result = read_result(worker_id)
            results.append({
                'workerId': worker_id,
                'taskId': task_id,
                'task': task,
                'result': result,
                'status': read_status(worker_id)['status']
            })

            write_status(worker_id, 'idle')

            if task.get('stopOnError') and not result.get('success'):
                print("[Orchestrator] Task failed, stopping")
                break

        return results

    def status(self):
        """Get status of all workers."""
        return [{'id': wid, 'status': read_status(wid)} for wid in self.workers]

    def shutdown(self):
        """Shut down orchestrator."""
        print("\n[Orchestrator] Shutting down")
        for worker_id in self.workers:
            write_status(worker_id, 'idle')


def main():
    if len(sys.argv) < 2:
        print("Usage: orchestrator <num_workers>", file=sys.stderr)
        print("\nExample: orchestrator 3", file=sys.stderr)
        sys.exit(1)

    try:
        num_workers = int(sys.argv[1])
    except ValueError:
        print("Error: num_workers must be an integer", file=sys.stderr)
        sys.exit(1)

    orch = Orchestrator(num_workers)

    print("\n" + "=" * 60)
    print("CLAUDE CODE ORCHESTRATOR")
    print("=" * 60)
    print(f"Workers: {num_workers}")
    print(f"Queue: ~/.claude-code/orchestrator/workers/")
    print("\nWorker Status:")
    print("-" * 40)

    for w in orch.status():
        print(f"Worker {w['id']}: {w['status']['status']}")

    print("\nOrchestrator ready. Workers waiting for tasks.")

    try:
        import signal
        signal.signal(signal.SIGINT, lambda s, f: (orch.shutdown(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (orch.shutdown(), sys.exit(0)))
        signal.pause()
    except KeyboardInterrupt:
        orch.shutdown()


if __name__ == '__main__':
    main()
